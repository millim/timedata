
## [系统设计] 累计服务设计



### 累计服务设计

#### 累计服务说明：

一个线上服务，对用户行为进行计数，可以支持可变时间段（最近X分钟，最近X小时，时间范围的终点永远是当前时间）的给定用户给定用户行为（评论，点赞，关注，发帖，等）次数的查询。查询来自于生产环境的API服务（调用量较大，对性能有要求）。

预先可知用户行为的枚举集合。

用户的行为在发生时（API服务接到请求时）会请求本服务进行写入，行为的时间是当前时间。



#### 对应的接口说明（用Golang表示）：

AddCount(userID int64, action string) error

写接口，每次用户的特定行为会调用AddCount，在当前时间对行为做一次计数。

userID: 长整型用户标识，唯一。

action: 可枚举的字符串，表示用户行为。

返回：error



GetCount(userID int64, action string, duration time.Duration) (int64, error)

读接口，查询给定用户、指定行为，在最近X时间段（终点是当前时间，长度由duration指定）的行为次数（来源：AddCount写入的数据）。

userID: 长整型用户标识，唯一。

action: 可枚举的字符串，表示用户行为。

duration: 时间段长度，终点是当前时间。

返回：int64, error   次数，是否有错误。



#### 其他说明：

Duration的粒度最小是1min，最长查询最近24小时的数据。

#### 接入场景：

抖音APP 6亿日均活跃用户的点赞行为。（读写请求量较大，并发高）



### 问题（请认真读题）
```
GO
假设有一个特别大内存的机器（暂时不用考虑单机存不下）。请使用Go语言的基本数据结构，设计合理的数据结构存储这个数据，用go写，并请写明注释说明。并用伪代码或者说明简单表述GetCount与AddCount的实现。能够说明流程即可。
```


### 要求：

+ 如果需要复杂的数据结构，可以使用伪代码代替，但是说明选择的理由。
+ GetCount与AddCount尽可能以高效的方式实现。
+ 使用的内存越小越好。
+ 如果能够考虑并发下的一致性更好，但是无需考虑竞态控制带来的overhead对性能的影响。因为假设条件是理论上的，单机实现无法避免高频率的竞态。但是良好的设计能够减少竞态。